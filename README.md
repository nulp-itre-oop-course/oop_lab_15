# Робота з лінійним двозв’язним списком
**Мета:** отримати практичні навички роботи з динамічними структурами даних у C++ — написати, відлагодити та протестувати програму, у якій реалізувати основні операції з двозв'язним списком.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ для  обробки даних з використанням лінійного двозв’язного списку.

Також реалізувати відповідні класи, конструктори, деструктори, методи. Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio Code з описом кожного класу у відповідних парах заголовного та виконуваного файлів.

## Завдання:
1.	Вибрати завдання згідно свого варіанту у **ДОДАТКУ**.
2.	Реалізувати клас, який представляє двозв'язний список. Елементом списку має бути дочірній клас, що наслідується від батьківського відповідно до заданого варіанту.
3.	Список повинен підтримувати наступні основні операції:
-	Створення базового класу для елемента списку.
-	Додавання елемента (на початок списку, на кінець списку, у вказану позицію після певного елемента).
-	Видалення елемента (з початку списку, з кінця списку, за значенням елемента).
-	Виведення елементів списку послідовно.
-	Виведення елементів списку послідовно (прямий вивід усіх елементів від head до tail, зворотний вивід усіх елементів від tail до head).
-	Перевірка чи елемент списку порожній.
-	Коректне видалення всіх вузлів списку при знищенні об'єкта.

### Короткі відомості
Двозв'язний список — це лінійна динамічна структура даних, де кожен елемент (вузол) містить не один, а два вказівники (посилання):
- next (наступний): вказівник на наступний вузол у послідовності.
- prev (попередній): вказівник на попередній вузол у послідовності.
Ця структура дозволяє здійснювати двонаправлену навігацію: ви можете легко переміщатися як вперед (до кінця списку), так і назад (до початку списку).

Основні компоненти двозв’язного списку:
- Вузол (Node) — базовий елемент, що містить дані, вказівник `next` та вказівник `prev`.
- Голова (Head) — вказівник на перший вузол. Його `prev` завжди має значення `nullptr`.
- Хвіст (Tail) — вказівник на останній вузол. Його `next` завжди має значення `nullptr`.
Головна перевага двозв'язного списку полягає у гнучкості навігації та ефективності деяких операцій:
- Двонаправлений рух — можливість ітерації у зворотному напрямку, починаючи з будь-якого вузла, що неможливо в однозв'язному списку.
- Ефективне видалення з кінця — операція видалення з кінця виконується за `O(1)` (константний час), оскільки останній вузол має прямий доступ до свого попереднього вузла (prev), що не вимагає проходу всього списку, як в однозв'язному списку (`O(n)`).
- Спрощене видалення — для видалення вузла, коли відомий лише сам вузол, а не його попередник, операція виконується за `O(1)`.
Недоліки  двозв'язного списку полягають у:
- Додаткові витрати пам'яті — кожен вузол містить додатковий вказівник (prev), що подвоює накладні витрати пам'яті на посилання порівняно з однозв'язним списком.
- Складніше обслуговування — операції вставлення та видалення вимагають маніпуляцій з чотирма вказівниками (вказівниками next та prev для двох сусідніх вузлів), що підвищує ризик помилок програмування.

Приклад реалізації двозв’язного списку мовою С++:
```c++
#include <iostream>
#include <stdexcept>

// Створення вузла (Node)
struct Node {
    int data;     // Дані
    Node* prev;   // Вказівник на попередній вузол
    Node* next;   // Вказівник на наступний вузол
    // Конструктор
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

// Клас двозв'язного списку
class DoublyLinkedList {
private:
    Node* head; // Вказівник на початок
    Node* tail; // Вказівник на кінець
public:
    // Конструктор
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}
    // Деструктор
    ~DoublyLinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* next_node = current->next;
            delete current;
            current = next_node;
        }
        head = tail = nullptr;
    }

    // Перевірка чи порожній елемент
    bool is_empty() const {
        return head == nullptr;
    }

    // Додавання на початок
    void push_front(int val) {
        Node* new_node = new Node(val);
        if (is_empty()) {
            head = tail = new_node;
        } else {
            new_node->next = head;
            head->prev = new_node;
            head = new_node;
        }
        std::cout << "Додано " << val << " на початок." << std::endl;
    }

    // Додавання в кінець
    void push_back(int val) {
        Node* new_node = new Node(val);
        if (is_empty()) {
            head = tail = new_node;
        } else {
            new_node->prev = tail;
            tail->next = new_node;
            tail = new_node;
        }
        std::cout << "Додано " << val << " на кінець." << std::endl;
    }

    // Видалення з початку
    int pop_front() {
        if (is_empty()) {
            throw std::out_of_range("Список порожній, неможливо видалити з початку.");
        }
        int val = head->data;
        Node* temp = head;
        if (head == tail) { // Список з одним елементом
            head = tail = nullptr;
        } else {
            head = head->next;
            head->prev = nullptr;
        }
        delete temp;
        return val;
    }

    // Видалення з кінця
    int pop_back() {
        if (is_empty()) {
            throw std::out_of_range("Список порожній, неможливо видалити з кінця.");
        }
        int val = tail->data;
        Node* temp = tail;
        if (head == tail) { // Список з одним елементом
            head = tail = nullptr;
        } else {
            tail = tail->prev;
            tail->next = nullptr; // Тепер новий останній вузол має нульовий 'next'
        }
        delete temp;
        return val;
    }
    // Прямий вивід списку
    void display_forward() const {
        if (is_empty()) {
            std::cout << "Список порожній." << std::endl;
            return;
        }
        Node* current = head;
        std::cout << "Прямий список: ";
        while (current != nullptr) {
            std::cout << current->data;
            if (current->next != nullptr) {
                std::cout << " <-> ";
            }
            current = current->next;
        }
        std::cout << std::endl;
    }

    // Зворотний вивід списку
    void display_backward() const {
        if (is_empty()) {
            std::cout << "Список порожній." << std::endl;
            return;
        }
        Node* current = tail;
        std::cout << "Зворотний список: ";
        while (current != nullptr) {
            std::cout << current->data;
            if (current->prev != nullptr) {
                std::cout << " <-> ";
            }
            current = current->prev;
        }
        std::cout << std::endl;
    }
};
```

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1.	Блок-схему алгоритму програми.
2.	Код (лістинг) програми.
3.	Результати тестування для різних вхідних умов.
4.	Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |       Батьківський клас       |                   Дочірні класи                  |
|----|-------------------------------|--------------------------------------------------|
|  1 | Джерело живлення              | Павербанк, бензиновий/дизель генератор           |
|  2 | Сенсор                        | Датчик температури, датчик світла                |
|  3 | Прилад                        | Мультиметр, осцилограф                           |
|  4 | Провідник сигналів            | Коаксіальний кабель, оптоволокно                 |
|  5 | Радіостанція                  | Базова станція, портативна рація                 |
|  6 | Мікросхема                    | Логічна мікросхема, пам’ять                      |
|  7 | Фільтр                        | Фільтр нижніх частот, смуговий фільтр            |
|  8 | Транзистор                    | Біполярний транзистор, польовий транзистор       |
|  9 | Напівпровідниковий діод       | Стабілітрон, тунельний діод                      |
| 10 | Комунікаційний пристрій       | Маршрутизатор, комутатор                         |
| 11 | Канал передавання даних       | Радіоканал, оптоволоконний канал                 |
| 12 | Двигун                        | Серводвигун, кроковий двигун                     |
| 13 | Зчитувач інформації           | Сканер штрих-коду, RFID-зчитувач                 |
| 14 | Електронна плата              | Макетна плата, друкована плата                   |
| 15 | Контролер                     | Мікроконтролер, програмований логічний контролер |
| 16 | Акумулятор                    | Літій-іонний, свинцево-кислотний                 |
| 17 | Антена                        | Всеспрямована антена, антена направленої дії     |
| 18 | Електромагнітний випромінювач | Світлодіод, лазер                                |
| 19 | Оптичний компонент            | Світлодіод, фоторезистор                         |
| 20 | Звуковий пристрій             | Мікрофон, динамік                                |
| 21 | Дисплей                       | Рідкокристалічний дисплей, OLED-дисплей          |
| 22 | Бездротова технологія         | WiFi, Bluetooth                                  |
| 23 | Операційна система            | Android, iOS                                     |
| 24 | Резонатор                     | Кварцовий резонатор, керамічний резонатор        |
| 25 | Супутниковий термінал         | Термінал для зв’язку, термінал для телебачення   |
| 26 | Датчик руху                   | Інфрачервоний датчик, радарний датчик            |
| 27 | Перетворювач напруги          | Підсилювач напруги, послаблювач напруги          |
| 28 | Реле                          | Електромагнітне реле, твердотільне реле          |
| 29 | Мобільний телефон             | Кнопковий телефон, смартфон                      |
| 30 | Електронний компонент         | Пасивний компонент, активний компонент           |
